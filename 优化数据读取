-- 为 user_usage 表创建索引

-- 1. 单列索引
-- 用户ID索引 - 用于按用户查询使用情况
CREATE INDEX idx_user_usage_user_id ON user_usage (user_id);

-- 时间戳索引 - 用于按时间范围查询
CREATE INDEX idx_user_usage_t ON user_usage (t);

-- 节点索引 - 用于按节点查询使用情况
CREATE INDEX idx_user_usage_node ON user_usage (node);

-- 2. 复合索引
-- 用户+时间复合索引 - 用于查询特定用户在特定时间范围的使用情况
CREATE INDEX idx_user_usage_user_time ON user_usage (user_id, t);

-- 用户+节点复合索引 - 用于查询特定用户在特定节点的使用情况
CREATE INDEX idx_user_usage_user_node ON user_usage (user_id, node);

-- 时间+节点复合索引 - 用于查询特定时间范围内特定节点的使用情况
CREATE INDEX idx_user_usage_time_node ON user_usage (t, node);

-- 3. 三列复合索引
-- 用户+时间+节点复合索引 - 用于最复杂的查询场景
CREATE INDEX idx_user_usage_user_time_node ON user_usage (user_id, t, node);

-- 4. 覆盖索引（可选）
-- 如果经常需要查询用户在特定时间的总流量，可以创建包含流量字段的覆盖索引
CREATE INDEX idx_user_usage_cover_traffic ON user_usage (user_id, t, u, d);












让我分析一下您的项目代码来提供具体的索引优化建议。基于您的 V2RaySocks 流量分析项目代码，我分析了数据库结构和查询模式，为您提供针对性的索引优化建议：

## 当前数据库结构分析

从代码中可以看到，核心表结构如下：

```sql
-- user 表
CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `uuid` varchar(36) NOT NULL,
  `sid` int NOT NULL,           -- 服务ID
  `u` bigint NOT NULL,          -- 总上传
  `d` bigint NOT NULL,          -- 总下载
  `enable` tinyint NOT NULL DEFAULT '1',
  -- ... 其他字段
  PRIMARY KEY (`id`)
);

-- user_usage 表（流量使用记录）
CREATE TABLE `user_usage` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `t` int NOT NULL,             -- 时间戳
  `u` bigint NOT NULL,          -- 上传流量
  `d` bigint NOT NULL,          -- 下载流量
  `node` varchar(50) NOT NULL,  -- 节点名称
  -- ... 其他字段
  PRIMARY KEY (`id`)
);
```

## 关键性能瓶颈

从 Monitor_DB.php 中的查询模式看，主要瓶颈在于：

1. **大量时间范围聚合查询**：5分钟、1小时、4小时、今日、7天等统计
2. **用户排名查询**：需要按服务ID、用户ID进行分组统计
3. **节点流量统计**：按节点名称进行分组聚合
4. **全历史统计查询**：可能导致全表扫描

## 推荐索引优化方案

### 1. user_usage 表核心索引

```sql name=user_usage_indexes.sql
-- 1. 时间戳索引（最重要）
CREATE INDEX idx_user_usage_time ON user_usage(t);

-- 2. 用户+时间复合索引（用户统计查询）
CREATE INDEX idx_user_usage_user_time ON user_usage(user_id, t);

-- 3. 节点+时间复合索引（节点统计查询）  
CREATE INDEX idx_user_usage_node_time ON user_usage(node, t);

-- 4. 服务ID索引（如果添加了service_id字段）
-- 首先添加service_id字段
ALTER TABLE user_usage ADD COLUMN service_id INT AFTER user_id;

-- 更新service_id（从user表获取sid）
UPDATE user_usage uu 
INNER JOIN user u ON uu.user_id = u.id 
SET uu.service_id = u.sid;

-- 创建服务ID相关索引
CREATE INDEX idx_user_usage_service_time ON user_usage(service_id, t);
CREATE INDEX idx_user_usage_service_user ON user_usage(service_id, user_id);
```

### 2. user 表索引优化

```sql name=user_indexes.sql
-- 1. 服务ID索引
CREATE INDEX idx_user_sid ON user(sid);

-- 2. 启用状态索引
CREATE INDEX idx_user_enable ON user(enable);

-- 3. 服务ID+启用状态复合索引
CREATE INDEX idx_user_sid_enable ON user(sid, enable);

-- 4. UUID索引（如果经常按UUID查询）
CREATE INDEX idx_user_uuid ON user(uuid);
```

### 3. 针对排名查询的优化索引

```sql name=ranking_indexes.sql
-- 用户流量排名查询优化
CREATE INDEX idx_user_usage_user_time_traffic ON user_usage(user_id, t, u, d);

-- 节点流量排名查询优化
CREATE INDEX idx_user_usage_node_time_traffic ON user_usage(node, t, u, d);

-- 如果添加了service_id，创建服务相关排名索引
CREATE INDEX idx_user_usage_service_time_traffic ON user_usage(service_id, t, u, d);
```

### 4. 覆盖索引优化（减少回表查询）

```sql name=covering_indexes.sql
-- 用户统计覆盖索引
CREATE INDEX idx_user_usage_user_cover ON user_usage(user_id, t, u, d, node);

-- 时间范围统计覆盖索引
CREATE INDEX idx_user_usage_time_cover ON user_usage(t, user_id, u, d, node);
```

## 查询优化建议

### 1. 时间范围查询优化

确保所有时间范围查询都使用索引：

```sql name=optimized_queries.sql
-- 优化前（可能全表扫描）
SELECT SUM(u + d) FROM user_usage WHERE t >= ?

-- 优化后（使用时间索引）
SELECT SUM(u + d) FROM user_usage WHERE t BETWEEN ? AND ?

-- 用户5分钟流量查询
SELECT user_id, SUM(u + d) as traffic 
FROM user_usage 
WHERE t >= ? AND t <= ?
GROUP BY user_id;

-- 节点流量统计
SELECT node, SUM(u + d) as traffic 
FROM user_usage 
WHERE t >= ? AND t <= ?
GROUP BY node;
```

### 2. 分页查询优化

```sql name=pagination_optimization.sql
-- 使用LIMIT优化大结果集
SELECT user_id, SUM(u + d) as total_traffic
FROM user_usage 
WHERE t >= ?
GROUP BY user_id
ORDER BY total_traffic DESC
LIMIT 100;

-- 避免大OFFSET，使用游标分页
SELECT * FROM user_usage 
WHERE t >= ? AND id > ?
ORDER BY id
LIMIT 1000;
```

## 实施建议

### 1. 分阶段实施

```sql name=implementation_plan.sql
-- 第一阶段：核心时间索引
CREATE INDEX idx_user_usage_time ON user_usage(t);
CREATE INDEX idx_user_usage_user_time ON user_usage(user_id, t);

-- 第二阶段：节点相关索引  
CREATE INDEX idx_user_usage_node_time ON user_usage(node, t);

-- 第三阶段：服务ID字段和索引
ALTER TABLE user_usage ADD COLUMN service_id INT;
-- 更新数据...
CREATE INDEX idx_user_usage_service_time ON user_usage(service_id, t);
```

### 2. 监控索引效果

```sql name=index_monitoring.sql
-- 检查索引使用情况
EXPLAIN SELECT user_id, SUM(u + d) 
FROM user_usage 
WHERE t >= UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 1 HOUR))
GROUP BY user_id;

-- 查看索引统计
SHOW INDEX FROM user_usage;

-- 监控慢查询
SHOW VARIABLES LIKE 'slow_query_log';
```

## 其他优化建议

1. **添加缓存机制**：对频繁查询的统计结果进行缓存
2. **数据分区**：按时间对 user_usage 表进行分区
3. **定期清理**：删除过期的历史数据
4. **读写分离**：统计查询使用只读从库

这些索引优化将显著提升您的流量分析系统的查询性能。建议先实施核心时间索引，然后根据实际查询模式逐步添加其他索引。

*注意：搜索结果可能不完整，您可以[在GitHub中查看更多代码](https://github.com/HsiaoweiYuen/V2RaySocks_Traffic_Analysis/search?q=CREATE+TABLE&type=code)来获取完整的数据库结构信息。*
